/**
 * 题目分为三种类型，
 * 1. 目前的情况：最终人格
 * 2. 想要成为的：潜在人格
 * 3. 一些脱离于16人格体系之外的：彩蛋人格
 *
 * 当这个题目是测试潜在人格的时候，会含有 potential 属性并且值为 true
 * 当这个题目能测试彩蛋人格的时候，会含有菜蛋人格的字段属性，值为一个函数
 *
 * 四个维度：
 * RQ 保证质量的程度
 * PC 保证功能，牺牲性能  的程度函数
 * FE 不专精保证探索
 * AV 不抽象喜欢形象交互
 *
 * 函数说明，
 * 通常为一个一次函数，也可能是更复杂的函数。
 * x的输入值是 区间 [-3 , 3] 上的整数。表示同意的程度
 * 返回值表示最终要加成多少或者减少多少分，在-1~+1之间
 *
 * 例如：RQ: (x) => 0.25 * x
 * 表示：
 * 3级同意的时候，将会在 “保证质量的程度” 这个维度上增加 0.75 分，
 * 2级不同意的时候，会在这个维度上减少 0.5 分
 *
 */

const QUESTION_ARRAY = [
    {
        content: "在面临一个紧急的项目交付期限时，你即使超时完成也会注重完成质量",
        RQ: (x) => 0.25 * x,
    },
    {
        content: "你目前认为程序写出bug是正常的事情，当被别人指出时不会羞耻和尴尬",
        RQ: (x) => -0.1 * x,
    },
    {
        content:
            "你完成了一个新功能的开发，但在代码审查中发现有一些潜在的优化和改进的地方，你愿意花更多时间进行全面的代码优化，以确保高质量。",
        RQ: (x) => 0.2 * (x + 1.5),
    },
    {
        content: "你认为做一件事情，无论做的再差劲，总比什么都不做强",
        RQ: (x) => 0.2 * x,
        FE: x => 0.1 * x,
    },
    {
        content: "你认为如果一件事情做的很差，那还不如不做（与上题恰相反，目的是让您仔细斟酌，两种都有道理，请保持两答案相反）",
        RQ: (x) => -0.2 * x,
        FE: x => -0.1 * x,
    },
    {
        content:
            "项目引入一项新技术，但这可能导致学习曲线和一些额外的开发时间。你希望希望尽快引入新技术，即使牺牲一些质量。",
        // -3  -2  -1  00  +1  +2  +3
        // 0.5 0.25 0  -0.25 ..... -0.4
        RQ: (x) => -0.2 * x,
        FE: (x) => 0.025 * (x - 3) ** 2 - 0.4,
    },
    {
        content: "你感觉算法比较复杂难懂",
        PC: (x) => 0.2 * x,
        AV: (x) => 0.3 * x,
    },
    {
        content: "你经常参加算法竞赛",
        PC: (x) => -0.15 * x,
        FE: (x) => 0.02 * x,
        AV: (x) => -0.2 * x,
        RQ: (x) => -0.01 * x,
    },
    {
        content: "即使被算法虐很多次，你会依然保持竞赛的热情",
        AV: (x) => -0.4 * x,
        PC: (x) => -0.3 * x,
    },
    {
        content: "你希望未来的项目中和算法相关的内容少一些，和功能业务直接相关的内容多一些",
        potential: true,
        PC: (x) => 0.25 * x,
    },
    {
        content: "你愿意牺牲一点可读性来优化性能",
        PC: (x) => -0.1 * x,
        AV: (x) => -0.01 * x,
    },
    {
        content: "当你不知怎么起变量名时，你可能会想一个大概差不多的英文名",
        RQ: (x) => -0.15 * x,
    },
    {
        content: "你经常会保证项目的功能稳定性，有些地方暂不考虑优化",
        PC: (x) => 0.2 * x,
    },
    {
        content: "你认为注释写得太详细会浪费时间，良好的代码是“自文档”的",
        RQ: (x) => -0.05 * (x - 1.5),
    },
    {
        content: "如果你写的代码有超级AI能准确无误的补全你的注释，你会很高兴",
        RQ: (x) => {
            if (x > 0) {
                return -0.01;
            }
            return 0;
        },
    },
    {
        content:
            "多数时候，相比新框架，你更愿意使用自己熟练掌握的方式和技术来做项目",
        FE: (x) => -0.22 * x,
    },
    {
        content: "你花了很多时间学习了很多不同的语言和框架，并且有人认为你会的很多",
        FE: (x) => 0.33 * x,
    },
    {
        content: '你目前还在上学，并且距离毕业还挺远的',
        FE: (x) => 0.5 * x,
    },
    {
        content: "你打算专精于一个领域，将来想成为一个专家",
        potential: true,
        FE: (x) => -0.33 * x,
    },
    {
        content: "你希望未来能更快的做出更多的东西，而不是只是把一个事情做好",
        potential: true,
        RQ: (x) => -0.1 * x,
    },
    {
        content:
            "你认为写出不同的前端界面、样式和UI交互很有趣（如果你还没学过和尝试过，请选择中立）",
        AV: (x) => {
            if (x === -3) {
                return -10;  // 强行修正，有些人特别不喜欢写UI。
            }
            return 0.75 * x
        },
    },
    {
        content: "当你写的程序能可视化，甚至能用鼠标等设备进行交互时，你会很高兴。",
        potential: true,
        AV: (x) => 0.15 * x,
        FE: (x) => 0.15 * x,
    },
    {
        content: "设计并做出一个庞大复杂的系统对你来说并不困难。",
        AV: (x) => -0.33 * x,
        PC: (x) => -0.1 * x,
    },
    {
        content: '除了写代码之外，你还经常搞搞AE、PS、剪视频、建模、动画等等视觉方面内容',
        potential: true,
        AV: (x) => {
            if (x > 0) {
                return 0.3 * x
            }
            return 0
        },
    },
    {
        content: "你希望未来能设计一个大后端系统",
        potential: true,
        AV: (x) => -0.33 * x,
        FE: (x) => -0.33 * x,
    },
    {
        content: '你对细节非常关注（从此题开始往下，都是在测试彩蛋人格）',
        BugHunter: x => 3 * x,
        Hacker: x => 0.2 * x,
    },
    {
        content: '你在发现他人代码中的bug时感到满足和有趣',
        BugHunter: x => 3 * x,
        Hacker: x => 2 * x,
    },
    {
        content: '你喜欢参与测试和调试过程，而不仅仅是编写代码',
        BugHunter: x => 3 * x,
        Hacker: x => 1 * x,
    },
    {
        content: '你经常追踪问题的根本原因，而不只是解决表面问题',
        BugHunter: x => 3 * x,
        Hacker: x => 2 * x,
    },
    {
        content: '当和别人合作发生不愉快时，你更容易悲伤而不是愤怒',
        Hacker: x => -3 * x,  // 黑客具有攻击行为、报复行为
    },
    {
        content: '你喜欢网络通信和安全方面的内容，并做过一些实践',
        Hacker: x => 4 * x,
    },
    {
        content: '你认为合法的网络渗透测试是一种不道德行为',
        Hacker: x => -4 * x,
    },
    {
        content: '当你发现一个系统存在漏洞时，你第一反应是赶快通知系统管理员解决这个bug',
        // 实际上黑客可能会看看这个bug还能如何利用，会先不告诉别人，自己摸索摸索
        // bugHunter 也会仔细思考一下这个bug的原因。立刻解决可能会掩盖更深层次的问题。
        Hacker: x => -4 * x,
        BugHunter: x => -3 * x,
        RQ: (x) => -0.05 * x,
    },
    {
        content: '你认为节假日是更好的时间来学习新技能，超越别人',
        EfficiencyMaster: x => 3 * x,
        LazyCoder: x => -1 * x,
    },
    {
        content: '你大多数时间都在写代码，甚至在别人娱乐的时候也在写代码',
        EfficiencyMaster: x => 3 * x,
        LazyCoder: x => -4 * x,
    },
    {
        content: '你期望更高的薪资而不是更少的工作',
        EfficiencyMaster: x => 3 * x,
        LazyCoder: x => -3 * x,
    },
    {
        content: '你愿意牺牲一点身体健康来换取很多技能提升',
        EfficiencyMaster: x => 2 * x,
        LazyCoder: x => -4 * x,
    },
    {
        content: '你认为在工作中保持轻松的心态比完成更多任务更为重要',
        EfficiencyMaster: x => -3 * x,
        LazyCoder: x => 3 * x,
    },
    {
        content: '你认为在工作中选择轻松项目是一种逃避',
        EfficiencyMaster: x => 1.5 * x,
        LazyCoder: x => -1.5 * x,
    },
    {
        content: '你认为在工作中休息片刻只会降低效率，没有实际意义',
        EfficiencyMaster: x => -1.8 * x,
        LazyCoder: x => 1.8 * x,
    },
];

const PERSONALITY = {
    AFRP: {
        name: "算法工程师",
        describe:
            "AFRP型程序员具有对抽象逻辑的深刻理解，喜欢使用熟悉的模式开发，并追求快速开发和卓越的性能。这种程序员倾向于探索新事物，但更注重使用已知的、熟悉的工具和模式。他们在追求高性能的同时，能够通过抽象思维构建复杂的逻辑结构。",
        motto:
            "在现实世界中，抽象是事物的本质。了解本质，你将能够构建更强大、更高效的系统。",
        advantage: `高度抽象思维： 擅长理解和构建抽象逻辑结构，能够处理复杂的问题。
    快速开发： 善于使用熟悉的工具和模式，以更快的速度实现功能。
    优秀性能： 注重性能优化，能够构建高效的代码，满足对系统性能的高要求。`,
        inferiority: `较强的依赖性： 可能过于依赖熟悉的工具和模式，对新技术的接受可能相对较慢。
    可能牺牲可读性： 为了追求性能和抽象，有时候可能会在代码可读性方面做一些妥协。`,
        recommendation: `拓宽视野： 尽管喜欢熟悉的模式，但时刻保持对新技术的敏感，尝试并学习新工具和框架。
    保持平衡： 在追求性能的同时，确保代码的可读性。清晰的代码对于团队协作和维护至关重要。
    参与社区： 参与技术社区和团队协作，与其他类型的程序员交流，拓宽技术视野。
    AFRP型程序员在团队中可能在性能优化和复杂逻辑处理方面发挥出色，但需要不断保持对新事物的开放态度，以确保在快速发展的技术领域中保持竞争力。`,
    },
    AFRC: {
        name: "后端工程师",
        describe: `AFRC型程序员注重抽象思维，更喜欢使用熟悉的模式进行后端工程开发，追求快速开发和高代码质量。他们倾向于使用已知的技术栈，同时关注系统的可维护性和代码质量。这种程序员对后端逻辑的抽象和处理有深入的了解。`,
        motto: `"在后端工程中，抽象是构建可维护系统的基石。快速开发和卓越的代码质量共同构成了优秀的后端工程。"`,
        advantage: `深度抽象思维： 对后端逻辑有深刻理解，能够构建高度抽象的系统。
    快速后端开发： 善于使用熟悉的后端工具和框架，以更快的速度实现功能。
    代码质量优秀： 关注代码质量，编写结构清晰、可维护的高质量代码。`,
        inferiority: `可能过于保守： 倾向于使用熟悉的技术栈，有时可能对新技术的接受相对较慢。
    可能忽视性能优化： 注重代码质量可能导致在性能方面做一些妥协，需要在追求质量的同时保持对性能的关注。`,
        recommendation: `尝试新技术： 保持对新技术的敏感度，尝试并学习新的后端工具和框架，以拓宽技术视野。
    平衡发展： 在追求快速开发的同时，保持代码的质量和可读性，找到二者之间的平衡点。
    团队协作： 参与团队协作，与其他类型的程序员共同合作，充分发挥各自的优势。
    AFRC型程序员在后端工程领域可能在高度抽象的系统设计和高质量的代码编写方面表现出色，但需要在保持代码质量的同时保持对新技术的开放态度，以适应快速发展的技术环境。`,
    },
    AFQP: {
        name: "数据分析师",
        describe: `AFQP型程序员是数据分析师，注重数据的抽象和处理，更喜欢使用熟悉的工具和模式进行数据分析，追求卓越的数据质量和高性能的数据处理。他们对数据抽象和统计分析有深入的理解，同时关注数据处理的效率和性能。`,
        motto: `"在数据分析领域，抽象和质量是数据科学的两大支柱。高性能的数据处理为深度分析提供了有力支持。"`,
        advantage: `深度数据抽象： 对数据的抽象和处理有深入的理解，能够进行高级别的数据分析。
    数据质量卓越： 关注数据的质量，善于清洗、整理和预处理数据，确保数据分析的准确性。
    高性能数据处理： 注重数据处理的效率和性能，能够处理大规模数据集。`,
        inferiority: `可能过于依赖熟悉工具： 倾向于使用熟悉的数据分析工具，对新工具的接受可能相对较慢。
    可能牺牲可读性： 追求性能和质量可能在代码可读性方面做一些妥协。`,
        recommendation: `学习新工具： 保持对新的数据分析工具和技术的学习，以适应不断发展的数据科学领域。
    平衡抽象和可读性： 在追求性能和质量的同时，确保代码的可读性，方便团队理解和维护。
    持续学习统计学： 深入学习统计学和数据分析方法，不断提高在数据领域的专业水平。
    AFQP型程序员在数据分析领域可能在高级别的数据抽象和处理方面表现出色，但需要保持对新技术的敏感度，以应对数据科学领域的不断变化。`,
    },
    AFQC: {
        name: "后端架构师",
        describe: `AFQC型程序员是后端架构师，专注于构建高度抽象的后端系统，更喜欢使用熟悉的技术栈，追求系统的质量和代码的可读性。他们对系统的整体架构和设计有深刻的理解，关注代码的清晰结构和可维护性。`,
        motto: `"在后端架构中，抽象是系统设计的基石。高质量的代码和良好的可读性共同构成了优秀的后端架构。"`,
        advantage: `深度系统抽象： 对后端系统的整体抽象和架构有深刻理解，能够设计高度复杂的系统。
    系统质量卓越： 追求系统的质量，编写高质量、稳定的后端代码。
    代码可读性强： 关注代码的结构和可维护性，编写清晰易懂的代码。`,
        inferiority: `可能保守： 倾向于使用熟悉的技术栈，对新技术的接受可能较慢。
    可能忽视性能优化： 注重系统质量可能导致在性能方面做一些妥协，需要平衡质量和性能。`,
        recommendation: `尝试新技术： 保持对新技术的敏感度，尝试并学习新的后端技术，以适应快速发展的技术环境。
    平衡质量和性能： 在追求系统质量的同时，保持对系统性能的关注，找到二者之间的平衡点。
    团队领导力： 发挥自己在系统设计和架构方面的优势，成为团队中的技术领导者。
    AFQC型程序员在后端架构领域可能在系统设计和质量保障方面表现出色，但需要保持对新技术的敏感度，以确保在快速发展的技术环境中保持竞争力。`,
    },
    AERP: {
        name: "算法竞赛人",
        describe: `AERP型程序员是算法竞赛人，专注于解决抽象、复杂的算法问题，喜欢探索新的算法和数据结构，追求在短时间内迅速找到高效的解决方案。他们对算法的抽象思维和快速实现有着深入的了解。`,
        motto: `"在算法竞赛中，抽象思维是解决问题的关键。快速、高效的算法实现是取得优势的秘诀。"`,
        advantage: `深度算法抽象： 对抽象问题的解决具有深刻理解，擅长在脑海中构建算法模型。
    善于探索： 对新的算法和数据结构充满好奇心，乐于尝试新的解决方案。
    快速实现： 能够在短时间内迅速实现复杂算法，适应竞赛的高压环境。`,
        inferiority: `可能过于专注： 在算法领域深耕可能导致对其他领域的了解相对较少。
    可能牺牲可读性： 为了速度和性能，有时可能在代码可读性方面做一些妥协。`,
        recommendation: `多元发展： 保持对其他领域的关注，扩展知识面，形成更全面的技术视野。
    交流经验： 参与算法竞赛社区，与其他竞赛者交流经验，学习不同的解题思路。
    关注工程实践： 尽管算法竞赛强调速度和高效率，但在实际工程中也要考虑可维护性和代码质量。
    AERP型程序员在算法竞赛领域可能在抽象思维和快速实现方面表现出色，但需要保持对多领域的兴趣，以适应不同的编程场景。`,
    },
    AERC: {
        name: "数据挖掘师",
        describe: `AERC型程序员是数据挖掘师，专注于探索数据，运用抽象的方法发现数据中的模式和趋势，追求在短时间内快速挖掘有价值的信息。他们对数据的抽象和分析有深入的理解，同时关注代码的清晰结构和可读性。`,
        motto: `"在数据挖掘领域，抽象和探索是发现隐藏信息的关键。快速而清晰的代码实现助力于更有效的数据挖掘。"`,
        advantage: `深度数据抽象： 对数据的抽象和分析有深入理解，能够运用抽象方法发现数据中的模式。
    善于探索： 对新的数据集和挖掘方法充满好奇心，乐于尝试新的数据分析技术。
    快速挖掘： 能够在短时间内迅速挖掘出数据中的有价值信息，适应快节奏的数据挖掘需求。`,
        inferiority: `可能过于专注： 在数据挖掘领域深耕可能导致对其他领域的了解相对较少。
    可能牺牲可读性： 为了速度和效率，有时可能在代码可读性方面做一些妥协。`,
        recommendation: `多元发展： 保持对其他领域的关注，尝试应用数据挖掘技术解决多领域问题。
    学习新技术： 数据挖掘领域技术日新月异，持续学习新的数据挖掘工具和方法。
    平衡抽象和可读性： 在追求挖掘效果的同时，确保代码的可读性，方便团队理解和维护。
    AERC型程序员在数据挖掘领域可能在抽象思维和快速挖掘方面表现出色，但需要保持对多领域的兴趣，以适应不断变化的数据科学环境。`,
    },
    AEQP: {
        name: "系统优化师",
        describe: `AEQP型程序员是系统优化师，专注于对系统性能进行抽象分析和优化，喜欢探索新的优化方法，追求在保证系统质量的同时提升系统性能。他们对系统的抽象思维和性能优化有深入的理解。`,
        motto: `"在系统优化中，抽象思维是提升性能的关键。优质的代码和高性能的系统共同构成了卓越的系统优化师。"`,
        advantage: `深度系统抽象： 对系统的整体抽象和性能分析有深刻理解，能够找到潜在的性能瓶颈。
    善于探索： 对新的优化方法和工具充满好奇心，乐于尝试新的系统性能优化策略。
    追求系统质量： 在性能优化的同时，注重系统的质量，确保系统的稳定性和可靠性。`,
        inferiority: `可能过于专注： 在系统优化领域深耕可能导致对其他领域的了解相对较少。
    可能牺牲可读性： 为了性能优化，有时可能在代码可读性方面做一些妥协。`,
        recommendation: `多元发展： 保持对其他领域的关注，尝试在不同场景中应用系统优化技术。
    学习新技术： 系统优化领域的工具和方法不断发展，需要持续学习新的优化技术。
    平衡抽象和可读性： 在追求性能优化的同时，确保代码的可读性，方便团队理解和维护。`,
    },
    AEQC: {
        name: "年轻的后端开发者",
        describe: `AEQC型程序员是年轻的后端开发者，专注于通过抽象思维和探索新技术，提供高质量、可维护的后端解决方案。他们对后端系统的抽象和代码质量有深入的理解，同时保持对新技术的好奇心。`,
        motto: `"年轻的后端开发者是技术进步的推动者。抽象思维和高质量的代码是构建未来系统的基石。"`,
        advantage: `积极学习： 对新技术和工具持有好奇心，愿意尝试并学习最新的后端开发技术。
    抽象思维： 具备较强的抽象思维，能够理解并设计复杂的后端系统。
    追求代码质量： 关注代码的结构和可读性，努力编写高质量、可维护的代码。`,
        inferiority: `经验相对较少： 由于是年轻的开发者，可能在某些经验丰富的领域还有待积累。
    可能过于追求新技术： 对新技术的好奇心可能导致在项目中过于追求尝试新技术。`,
        recommendation: `学习积累： 不断积累实际项目经验，通过实践提升自己的技术水平。
    多角度思考： 除了追求新技术，也要考虑技术的实际应用和业务场景。
    与团队合作： 在团队中学习和合作，与经验丰富的同事交流，获取更多经验。
    AEQC型程序员作为年轻的后端开发者，具备积极学习的特质，需要在实践中不断成长，平衡好对新技术的追求和对系统质量的关注。`,
    },
    VFRP: {
        name: "游戏开发者",
        describe: `VFRP型程序员是游戏开发者，专注于创造形象生动、熟悉游戏开发模式的游戏体验。他们追求高效的开发流程，注重游戏的视觉效果和性能表现，喜欢利用熟悉的工具和模式进行游戏开发。`,
        motto: `"游戏开发者是创造虚拟世界的艺术家。形象生动的视觉效果和高性能是游戏开发的核心追求。"`,
        advantage: `视觉创造力： 具备出色的视觉创意，能够设计出引人入胜的游戏画面和交互界面。
    熟悉游戏模式： 对游戏开发的常用模式和引擎有深入的了解，能够高效开发游戏。
    追求高性能： 注重游戏的性能表现，确保游戏在各种平台上流畅运行。`,
        inferiority: `可能局限于游戏领域： 对其他领域的了解相对较少，可能局限于游戏开发的范围。
    可能牺牲可读性： 为了高效开发，有时可能在代码可读性方面做一些妥协。`,
        recommendation: `多元发展： 尽管是游戏开发者，也要保持对其他领域的关注，拓宽技术视野。
    关注新技术： 游戏开发领域技术不断创新，保持对新技术的敏感性。
    平衡抽象和可读性： 在追求游戏效果的同时，确保代码的可读性，方便团队理解和维护。
    VFRP型程序员作为游戏开发者，具备强大的视觉创意和高效的开发能力，需要在实践中不断平衡创造性和代码质量。`,
    },
    VFRC: {
        name: "前端CI/CD专家",
        describe: `VFRC型程序员是前端CI/CD专家，专注于打造形象生动的前端交互和界面，并在持续集成和交付流程中追求高效的开发。他们熟悉前端开发模式，注重代码质量和可读性，致力于构建可靠的CI/CD流水线。`,
        motto: `"前端CI/CD专家是构建高效前端工作流的引领者。形象生动的界面和可靠的持续集成是前端开发的核心。"`,
        advantage: `前端创造力： 具备出色的前端创意，能够设计出引人入胜的交互界面。
    熟悉前端模式： 对前端开发的常用模式和工具有深入了解，能够高效开发前端应用。
    持续集成专业： 精通CI/CD流程，能够建立高效的前端持续集成和交付流水线。`,
        inferiority: `可能过于专注： 在前端领域深耕可能导致对其他领域的了解相对较少。
    可能过分追求速度： 为了高效的CI/CD流程，有时可能在代码可读性方面做一些妥协。`,
        recommendation: `多元发展： 尽管是前端CI/CD专家，也要保持对其他领域的关注，拓宽技术视野。
    关注新技术： 前端技术不断创新，保持对新技术的敏感性，以提升工作效率。
    平衡抽象和可读性： 在追求前端效果的同时，确保代码的可读性，方便团队理解和维护。
    VFRC型程序员作为前端CI/CD专家，具备强大的前端创意和CI/CD专业技能，需要在实践中不断平衡创造性和代码质量。`,
    },
    VFQP: {
        name: "游戏优化师",
        describe: `VFQP型程序员是游戏优化师，专注于提升游戏的视觉质量和性能表现。他们熟悉游戏开发模式，追求高质量的游戏画面和卓越的性能，同时注重熟悉的开发模式。`,
        motto: `"游戏优化师是创造令人惊艳游戏体验的魔术师。高质量的画面和出色的性能是游戏优化的终极目标。"`,
        advantage: `视觉创造力： 具备卓越的视觉创意，能够设计出高质量的游戏画面和交互界面。
    熟悉游戏模式： 对游戏开发的常用模式和引擎有深入了解，能够高效开发游戏。
    注重质量和性能： 追求高质量的视觉效果和出色的性能表现，确保游戏在各种平台上流畅运行。`,
        inferiority: `可能局限于游戏领域： 对其他领域的了解相对较少，可能局限于游戏开发的范围。
    可能牺牲可读性： 为了优化性能，有时可能在代码可读性方面做一些妥协。`,
        recommendation: `多元发展： 保持对其他领域的关注，拓宽技术视野，尝试在不同领域应用优化技术。
    关注新技术： 游戏优化领域技术不断创新，保持对新技术的敏感性。
    平衡抽象和可读性： 在追求游戏效果和性能的同时，确保代码的可读性，方便团队理解和维护。
    VFQP型程序员作为游戏优化师，具备强大的视觉创意和性能优化技能，需要在实践中不断平衡创造性和代码质量。`,
    },
    VFQC: {
        name: "前端架构师",
        describe: `VFQC型程序员是前端架构师，专注于设计和构建高质量、可维护的前端架构。他们熟悉前端开发模式，追求高质量的代码和架构设计，同时注重形象生动的前端交互和界面。`,
        motto: `"前端架构师是构建可靠前端系统的建筑师。高质量的代码和出色的架构是前端开发的基石。"`,
        advantage: `前端创造力： 具备出色的前端创意，能够设计出引人入胜的交互界面。
    熟悉前端模式： 对前端开发的常用模式和工具有深入了解，能够高效开发前端应用。
    注重质量和可维护性： 追求高质量的代码和可维护的架构设计，确保前端系统的稳定性。`,
        inferiority: `可能过于专注： 在前端领域深耕可能导致对其他领域的了解相对较少。
    可能过分注重质量： 为了保证高质量的代码和架构，有时可能在开发速度方面做一些妥协。`,
        recommendation: `多元发展： 尽管是前端架构师，也要保持对其他领域的关注，拓宽技术视野。
    关注新技术： 前端技术不断创新，保持对新技术的敏感性，以提升前端系统的效率。
    平衡抽象和可读性： 在追求前端效果和架构设计的同时，确保代码的可读性，方便团队理解和维护。
    VFQC型程序员作为前端架构师，具备强大的前端创意和架构设计能力，需要在实践中不断平衡创造性和代码质量。`,
    },
    VERP: {
        name: "全栈工程师",
        describe: `VERP型程序员是全栈工程师，擅长前后端开发以及系统设计，注重快速开发和高质量的代码。他们喜欢探索新事物，追求形象生动的前端交互和界面，同时关注后端系统的设计和性能。`,
        motto: `"全栈工程师是技术的探险家，同时是前后端的建筑师。快速开发和高质量的代码是全栈开发的标志。"`,
        advantage: `技术广泛： 擅长前后端开发和系统设计，具备全方位的技术能力。
    探索精神： 喜欢尝试新技术和新领域，保持对技术的好奇心。
    快速开发： 注重快速迭代，能够迅速开发并交付高质量的系统。`,
        inferiority: `可能过于广泛： 对某一领域深入了解相对较少，可能导致对特定问题的解决不够深入。
    可能过分追求速度： 为了迅速开发，有时可能在代码可读性方面做一些妥协。`,
        recommendation: `深耕重点领域： 在广泛涉猎的同时，深耕某一领域，提升在该领域的专业水平。
    保持好奇心： 持续关注新技术和行业趋势，保持对技术的好奇心。
    平衡抽象和可读性： 在追求前后端系统效果的同时，确保代码的可读性，方便团队理解和维护。
    VERP型程序员作为全栈工程师，具备广泛的技术能力和探索精神，需要在实践中不断平衡广泛性和深度。`,
    },
    VERC: {
        name: "前端工程师",
        describe: `VERC型程序员是前端工程师，专注于前端开发领域，注重探索新技术和迅速开发高质量的前端应用。他们喜欢形象生动的前端交互和界面，同时关注代码的可读性。`,
        motto: `"前端工程师是创造用户与网站之间桥梁的艺术家。迅速交付和可读性高的代码是前端开发的核心。"`,
        advantage: `前端创造力： 具备出色的前端设计和交互创意，能够打造引人入胜的用户界面。
    探索精神： 喜欢尝试新技术和新领域，保持对前端技术的好奇心。
    快速开发： 注重迅速迭代，能够迅速开发并交付高质量的前端应用。`,
        inferiority: `可能过分注重前端： 对其他领域了解相对较少，可能局限于前端开发的范畴。
    可能过分追求速度： 为了迅速开发，有时可能在代码可读性方面做一些妥协。`,
        recommendation: `多学多练： 保持对其他领域的好奇心，尝试拓宽技术领域，提升自己的综合能力。
    关注新技术： 前端技术日新月异，保持对新技术的敏感性，以保持前沿的竞争力。
    平衡抽象和可读性： 在追求前端效果的同时，确保代码的可读性，方便团队理解和维护。
    VERC型程序员作为前端工程师，具备出色的前端创意和快速开发能力，需要在实践中不断平衡创造性和代码质量。`,
    },
    VEQP: {
        name: "可视化工程师",
        describe: `VEQP型程序员是可视化工程师，专注于设计和开发可视化界面和图形化展示。他们喜欢探索新的可视化技术和追求高质量的可视化效果，同时注重性能的优化。`,
        motto: `"可视化工程师是信息传达的艺术家，通过视觉呈现复杂数据。高质量的可视化效果和优化的性能是可视化工程师的追求。"`,
        advantage: `创造性可视化： 具备设计和开发高质量可视化效果的能力，能够生动地呈现复杂数据。
    探索新技术： 喜欢尝试新的可视化技术和工具，保持对领域内技术的好奇心。
    注重质量和性能： 追求高质量的可视化效果的同时，注重性能的优化，确保用户体验。`,
        inferiority: `可能过于专注： 在可视化领域深耕可能导致对其他领域的了解相对较少。
    可能过分注重细节： 追求高质量可能导致在性能方面做一些妥协。`,
        recommendation: `多元发展： 尽管是可视化工程师，也要保持对其他领域的关注，拓宽技术视野。
    关注新技术： 可视化技术不断创新，保持对新技术的敏感性，以提升可视化效果。
    平衡质量和性能： 在追求高质量的可视化效果的同时，确保性能的优化，以保持用户体验。
    VEQP型程序员作为可视化工程师，具备创造性的可视化能力，需要在实践中不断平衡创造性和性能优化。`,
    },
    VEQC: {
        name: "前端框架开拓者",
        describe: `VEQC型程序员是前端框架开拓者，专注于前端框架的探索和开发。他们喜欢探索新的前端技术和框架，追求高质量的代码和可视化效果。`,
        motto: `"前端框架开拓者是前端技术的创新者，通过框架的开发推动前端领域的发展。高质量的代码和卓越的可视化效果是前端框架开拓者的目标。"`,
        advantage: `框架创新： 具备设计和开发前端框架的能力，善于探索新的前端技术方向。
    探索精神： 喜欢尝试新的前端技术和框架，保持对领域内技术的好奇心。
    注重质量和可读性： 追求高质量的代码的同时，注重代码的可读性，方便框架的使用和维护。`,
        inferiority: `可能过于专注： 在前端框架的开发中深耕可能导致对其他领域的了解相对较少。
    可能过分追求框架复杂性： 为了创新可能导致框架过于复杂，不易上手。`,
        recommendation: `多元发展： 尽管是前端框架开拓者，也要保持对其他领域的关注，拓宽技术视野。
    关注行业需求： 前端领域快速变化，保持对行业需求的敏感性，以提升框架的实用性。
    平衡质量和可读性： 在追求高质量的代码的同时，确保代码的可读性，方便框架的使用和维护。
    VEQC型程序员作为前端框架开拓者，具备创新性的前端框架开发能力，需要在实践中不断平衡创新性和框架的实用性。`,
    },
    LazyCoder: {
        name: '摸鱼者',
        describe: '摸摸fish，喜欢轻松自在，擅长规避繁琐',
        motto: `人间清醒、悠闲而不失效率`,
        advantage: `快速完成任务，保持轻松的工作氛围`,
        inferiority: `被发现了可能会出事`,
        recommendation: `注意保持任务的整体质量，不要牺牲过多细节，留心监控软件，摄像头，必要时使用手机热点网络`
    },
    EfficiencyMaster: {
        name: '卷王',
        describe: '以高效为己任，追求工作和学习的极致效果',
        motto: `卷死别人，成就自己，效率即王道`,
        advantage: `学习能力强`,
        inferiority: `注意身体`,
        recommendation: `建议平衡生活和工作，注意锻炼和饮食`
    },
    Hacker: {
        name: '黑客',
        describe: '有着丰富的网络攻防知识和经验，具备独特的技术洞察力',
        motto: `游走在网络的世界中`,
        advantage: `学习能力强`,
        inferiority: `可能忽视一些伦理道德因素，在做项目时有时可能过于谨慎，影响创新`,
        recommendation: `建议在学习和实践计算机网络技术的同时也关注计算机安全法律相关内容，在确保系统安全的前提下，鼓励创新思维`
    },
    BugHunter: {
        name: '找bug专家',
        describe: '对细节敏感，善于发现并解决问题',
        motto: `每个bug都是一个学习的机会`,
        advantage: `准确发现和解决问题，提高代码质量`,
        inferiority: `可能过于关注细节而忽略整体进度`,
        recommendation: `在保持对细节关注的同时，注意整体任务的推进`
    }
};
